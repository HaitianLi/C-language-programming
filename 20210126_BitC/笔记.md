# C语言操作符2


### ~ 按位取反

让二进制数0变1, 1变0

简单的运用取反

```c
int main() {
    int a = 0;
    //scanf()读一个数, 读到了是1, 没读到是-1, 这里-1取反是0, 停止while循环
    while (~scanf("%d", &a)) {
        ;
    }
    return 0;
}
```

### ++, --

简单的迭代, 不要深究, 代码的可读性需要注意

前置是先迭代后使用, 后置是先使用后迭代

### 强制类型转换

int a = (int)3.14;

在写程序的时候最好数据类型对上, 在万不得已的时候才用强制类型转换, 同时大转小可能造成数据的丢失.

### 逻辑与,逻辑或

&& 逻辑与
|| 逻辑或

```c
int main() {
    int i = 0, a = 0, b = 2, c = 3, d= 4;
    i = a++ && ++b && d++;
    printf("a = %d\nb=%d\nc = %d\nd = %d\n", a, b, c, d)
    printf("%d\n", i)
    return 0;
}
```
其中a = 1, b = 2, c = 3, d = 4 i = 0
因为a的值是后置迭代,而a的原始值为0, 所以逻辑与查到左侧的值为0, 后面的操作都没有计算直接返回了0.

同样的操作适用于逻辑或||, 如果左侧一旦有值不等于0, 则后面的运算不会执行.

这两种现象被称作短路现象

### 条件操作符(三目操作符)

```c
int main() {
    printf("%d\n", (5 > 2)?3:1);
}
```
### 逗号表达式

运算顺序是从左至右, 表达式的结果取决于最后一个表达式.

不经常用, 造成代码的可读性下降

### 下标引用操作符

int arr[10] = {0};

arr[4] = 4; // []就是下标引用操作符

### 函数调用操作符

```c
void test() {
    printf("hehe");
}

int main() {
    test(); // 函数调用操作符
    return 0;
}
```
### 结构成员访问操作符(联合体)

```c
struct Stu {
    char name[20];
    int age;
    char sex[5];
};

int main() {
    struct Stu s = {"张三", 20, ”男”};

    printf("%s\n", s.name);
    printf("%d\n", s.age);
    printf("%s\n", s.sex);
    
    //通用指针
    struct Stu * ps = &s;
    printf("%S\n", ps->name);
    printf("%S\n", (*ps).name);
    //->用于结构体指针
    return 0;
}
```

## 隐式类型转换
### 整型提升

表达式的整型运算要在CPU的相应运算器内执行, CPU内整型运算器ALU的操作数的字节长度一般是int字节的长度, 同时也是CPU通用寄存器的长度

因此, 即使两个char 类型的相加, 在CPU执行时实际上也要现转换位CPU内部的整型操作数的长度,也就是int

所以通用CPU是难以直接实现两个8bit位的运算, 需要提升至int

计算整型的时候, 变量内能存储的bit位小于int,则会发生截断并进行整型提升.

```c
int main() {
    
    //这里char 等价于 signed char
    char a = 3;
    //00000000000000000000000000000011 截断
    //00000011 这里的a, 因为用char类型储存

    char b = 127;
    //00000000000000000000000001111111 截断
    //01111111 这里是b

    char c = a + b;
    //a 和 b的大小不够一个整型大小, 所以要发生整型提升
    //整型提升是按照变量愿符号为来提升的
    //这里a需要提升为整型, 高位全部补0, 这里b也一样, 如果是负数,则高位补1
    //00000000000000000000000000000011
    //00000000000000000000000001111111
    //00000000000000000000000010000010 这里a和b整型提升之后相加
    //所以c最后的值是10000010, 在char中
    //又因为c要整型输出, 所以c也要整型提升, 又因为是signed char 所以最高位补了1
    //所以最后c的值为
    //11111111111111111111111110000010 这里是补码
    //11111111111111111111111110000001 反码
    //10000000000000000000000001111110 源码
    //最后c的值为-126
    printf("%d\n", c);

    return 0
}
```

这个代码在不同的系统和编译器下输出不同的值, 没有标准答案, 是反面例子, 程序员写出的表达式如果不能通过操作符的属性确定唯一的计算路径, 那么这个表达式就是存在问题的

```c
int main() {    
    int i = 1;
    int a = (++i) + (++i) + (++i);
    printf("%d\n", a);
    return 0;
}
```


## 常用的寄存器

1. ebp
   1. 经常用来放地址
2. esp
   1. 经常用来放地址
3. eax
4. ebx
5. ecx
6. edx











